//This file was generated by AI - spherical wall generation
//Approach: centerline graph → offset boundary → extrude
import * as THREE from 'three';

const FACES = 6;

/**
 * Calculate spherized vertex grid for all faces (tile corners)
 */
export function calculateFaceVertices(size, divisions) {
  const radius = size / 2;
  const subDist = size / divisions;
  const half = size / 2;

  const faceVertices = [];

  for (let face = 0; face < FACES; face++) {
    faceVertices[face] = [];
    for (let i = 0; i <= divisions; i++) {
      faceVertices[face][i] = [];
      for (let j = 0; j <= divisions; j++) {
        let v;
        switch (face) {
          case 0:
            v = new THREE.Vector3(i * subDist - half, half - j * subDist, half);
            break;
          case 1:
            v = new THREE.Vector3(half, half - j * subDist, half - i * subDist);
            break;
          case 2:
            v = new THREE.Vector3(
              half - i * subDist,
              half - j * subDist,
              -half
            );
            break;
          case 3:
            v = new THREE.Vector3(
              -half,
              half - j * subDist,
              i * subDist - half
            );
            break;
          case 4:
            v = new THREE.Vector3(i * subDist - half, half, j * subDist - half);
            break;
          case 5:
            v = new THREE.Vector3(
              i * subDist - half,
              -half,
              half - j * subDist
            );
            break;
        }
        v.normalize().multiplyScalar(radius);
        faceVertices[face][i][j] = v;
      }
    }
  }
  return faceVertices;
}

/**
 * Generate wall meshes using centerline → offset → extrude approach
 */
export function generateWalls(
  faceVertices,
  tiles,
  radius,
  scene,
  options = {}
) {
  const { wallHeight = 0.15, wallThickness = 0.02 } = options;
  const N = tiles[0].length;
  const material = new THREE.MeshStandardMaterial({
    color: 0x606060,
    wireframe: false,
    roughness: 1.0,
    metalness: 0.0,
  });

  const tileSize = (Math.PI * radius) / (2 * N);
  const mergeThreshold = tileSize * 0.15; // Slightly larger to ensure seam vertices merge

  // Collect ALL edges from ALL faces first (this allows seam unification)
  const allEdges3D = [];

  for (let face = 0; face < FACES; face++) {
    const verts = faceVertices[face];
    const edges = collectWallEdges(tiles[face], N);

    // Convert grid edges to 3D and add to global list
    for (const e of edges) {
      allEdges3D.push({
        v1: verts[e.x1][e.y1].clone(),
        v2: verts[e.x2][e.y2].clone(),
      });
    }
  }

  if (allEdges3D.length === 0) {
    console.log('No wall edges found');
    return;
  }

  // Build merged centerline graph from ALL edges globally
  // This will merge vertices at seams since they're at the same 3D position
  const { vertices, edgeIndices } = buildCenterlineGraph(
    allEdges3D,
    mergeThreshold
  );

  // Find connected components
  const components = findComponents(vertices.length, edgeIndices);

  let componentCount = 0;

  // Build geometry for each component
  for (const componentEdges of components) {
    const geometry = buildWallFromCenterline(
      vertices,
      componentEdges,
      radius,
      wallHeight,
      wallThickness / 2
    );

    if (geometry) {
      scene.add(new THREE.Mesh(geometry, material));
      componentCount++;
    }
  }

  console.log(
    `Wall components: ${componentCount} from ${allEdges3D.length} edges`
  );
}

/**
 * Collect wall edges from tile passages
 */
function collectWallEdges(faceTiles, N) {
  const edges = [];

  for (let y = 0; y <= N; y++) {
    for (let x = 0; x < N; x++) {
      let hasWall =
        y === 0
          ? !faceTiles[x][0]._passages.top
          : y === N
          ? !faceTiles[x][N - 1]._passages.bottom
          : !faceTiles[x][y]._passages.top;
      if (hasWall) {
        edges.push({ x1: x, y1: y, x2: x + 1, y2: y });
      }
    }
  }

  for (let x = 0; x <= N; x++) {
    for (let y = 0; y < N; y++) {
      let hasWall =
        x === 0
          ? !faceTiles[0][y]._passages.left
          : x === N
          ? !faceTiles[N - 1][y]._passages.right
          : !faceTiles[x][y]._passages.left;
      if (hasWall) {
        edges.push({ x1: x, y1: y, x2: x, y2: y + 1 });
      }
    }
  }

  return edges;
}

/**
 * Build the centerline graph by merging nearby vertices
 */
function buildCenterlineGraph(edges3D, threshold) {
  const allPoints = [];
  for (const edge of edges3D) {
    allPoints.push(edge.v1.clone());
    allPoints.push(edge.v2.clone());
  }

  // Merge close vertices
  const mergedVertices = [];
  const pointToIndex = [];

  for (let i = 0; i < allPoints.length; i++) {
    const p = allPoints[i];
    let foundIdx = -1;

    for (let j = 0; j < mergedVertices.length; j++) {
      if (p.distanceTo(mergedVertices[j]) < threshold) {
        foundIdx = j;
        break;
      }
    }

    if (foundIdx >= 0) {
      pointToIndex[i] = foundIdx;
    } else {
      pointToIndex[i] = mergedVertices.length;
      mergedVertices.push(p.clone());
    }
  }

  // Build edge list with merged indices, deduplicating edges
  const edgeIndices = [];
  const edgeSet = new Set();

  for (let i = 0; i < edges3D.length; i++) {
    const idx1 = pointToIndex[i * 2];
    const idx2 = pointToIndex[i * 2 + 1];
    if (idx1 !== idx2) {
      // Create canonical edge key (smaller index first)
      const key = idx1 < idx2 ? `${idx1}-${idx2}` : `${idx2}-${idx1}`;
      if (!edgeSet.has(key)) {
        edgeSet.add(key);
        edgeIndices.push([idx1, idx2]);
      }
    }
  }

  return { vertices: mergedVertices, edgeIndices };
}

/**
 * Find connected components
 */
function findComponents(vertexCount, edgeIndices) {
  if (edgeIndices.length === 0) return [];

  const parent = Array.from({ length: vertexCount }, (_, i) => i);
  const find = (x) => (parent[x] === x ? x : (parent[x] = find(parent[x])));
  const union = (a, b) => (parent[find(a)] = find(b));

  for (const [i1, i2] of edgeIndices) {
    union(i1, i2);
  }

  const components = new Map();
  for (const edge of edgeIndices) {
    const root = find(edge[0]);
    if (!components.has(root)) components.set(root, []);
    components.get(root).push(edge);
  }

  return Array.from(components.values());
}

/**
 * Build wall geometry from centerline graph
 * 1. Compute boundary points at each vertex (offset from centerline)
 * 2. For each edge, create wall using the boundary points at both ends
 * 3. Junction fill is implicit - edges share boundary points
 */
function buildWallFromCenterline(
  vertices,
  edgeIndices,
  radius,
  height,
  halfThick
) {
  const outerRadius = radius + height;

  // Build adjacency with sorted neighbors
  const adj = new Map();
  for (const [i1, i2] of edgeIndices) {
    if (!adj.has(i1)) adj.set(i1, []);
    if (!adj.has(i2)) adj.set(i2, []);
    adj.get(i1).push(i2);
    adj.get(i2).push(i1);
  }

  // For each vertex, sort neighbors by angle and compute boundary points in "slots"
  const vertexSlots = new Map();

  for (const [vertIdx, neighbors] of adj) {
    const v = vertices[vertIdx];
    const outward = v.clone().normalize();

    // Sort neighbors by angle around the vertex
    const sorted = sortByAngle(v, neighbors, vertices, outward);

    // Compute boundary point in each slot (between consecutive sorted neighbors)
    const slots = [];
    const n = sorted.length;

    if (n === 1) {
      // Dead end - create two slots (left and right of the single edge)
      const neighborIdx = sorted[0];
      const dir = vertices[neighborIdx].clone().sub(v).normalize();
      const perpLeft = getEdgePerpendicular(dir, outward);
      const perpRight = perpLeft.clone().negate();

      // Left slot
      slots.push({
        point: v.clone().add(perpLeft.clone().multiplyScalar(halfThick)),
        prevNeighbor: neighborIdx,
        nextNeighbor: neighborIdx,
        isLeft: true,
      });
      // Right slot
      slots.push({
        point: v.clone().add(perpRight.clone().multiplyScalar(halfThick)),
        prevNeighbor: neighborIdx,
        nextNeighbor: neighborIdx,
        isLeft: false,
      });
    } else {
      // Multiple neighbors - compute miter points between adjacent edges
      for (let i = 0; i < n; i++) {
        const prevIdx = sorted[(i - 1 + n) % n];
        const currIdx = sorted[i];

        // Directions to neighbors
        const dirPrev = vertices[prevIdx].clone().sub(v).normalize();
        const dirCurr = vertices[currIdx].clone().sub(v).normalize();

        // Perpendicular directions pointing into this slot (robust computation)
        // perpPrev points to the RIGHT of edge going toward prevIdx
        // perpCurr points to the LEFT of edge going toward currIdx
        const perpPrev = getEdgePerpendicular(dirPrev, outward).negate();
        const perpCurr = getEdgePerpendicular(dirCurr, outward);

        // Compute miter intersection
        const slotPoint = computeMiterSimple(
          v,
          dirPrev,
          dirCurr,
          perpPrev,
          perpCurr,
          halfThick,
          outward
        );

        slots.push({
          point: slotPoint,
          prevNeighbor: prevIdx,
          nextNeighbor: currIdx,
        });
      }
    }

    vertexSlots.set(vertIdx, { sorted, slots });
  }

  // Now build geometry
  const positions = [];
  const indices = [];
  let vertOffset = 0;

  // For each edge, find the boundary points at each end and create wall quad
  for (const [i1, i2] of edgeIndices) {
    const result = createEdgeGeometry(
      vertices[i1],
      vertices[i2],
      i1,
      i2,
      vertexSlots,
      radius,
      outerRadius
    );

    for (const p of result.positions) positions.push(p);
    for (const idx of result.indices) indices.push(idx + vertOffset);
    vertOffset += result.positions.length / 3;
  }

  // Add caps at dead ends and fill at junctions
  for (const [vertIdx, data] of vertexSlots) {
    if (data.sorted.length === 1) {
      // Dead end cap
      const result = createDeadEndCap(
        vertices[vertIdx],
        data.slots,
        radius,
        outerRadius
      );

      for (const p of result.positions) positions.push(p);
      for (const idx of result.indices) indices.push(idx + vertOffset);
      vertOffset += result.positions.length / 3;
    } else if (data.sorted.length >= 3) {
      // Junction fill (T, +, etc) - fill the top and bottom polygons
      const result = createJunctionFill(
        vertices[vertIdx],
        data.slots,
        radius,
        outerRadius
      );

      for (const p of result.positions) positions.push(p);
      for (const idx of result.indices) indices.push(idx + vertOffset);
      vertOffset += result.positions.length / 3;
    }
  }

  if (positions.length === 0) return null;

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setIndex(indices);

  // Compute normals and bounding volumes
  geo.computeVertexNormals();
  geo.computeBoundingSphere();
  geo.computeBoundingBox();

  return geo;
}

/**
 * Sort neighbor indices by angle around vertex
 */
function sortByAngle(vertex, neighbors, allVertices, outward) {
  // Get tangent basis for the sphere at this point
  const tangent1 = getTangent(outward);
  const tangent2 = new THREE.Vector3()
    .crossVectors(outward, tangent1)
    .normalize();

  return [...neighbors].sort((a, b) => {
    const dirA = allVertices[a].clone().sub(vertex);
    const dirB = allVertices[b].clone().sub(vertex);

    const angleA = Math.atan2(dirA.dot(tangent2), dirA.dot(tangent1));
    const angleB = Math.atan2(dirB.dot(tangent2), dirB.dot(tangent1));

    return angleA - angleB;
  });
}

/**
 * Get a consistent tangent vector for a normal
 */
function getTangent(normal) {
  const up = new THREE.Vector3(0, 1, 0);
  if (Math.abs(normal.dot(up)) > 0.99) {
    return new THREE.Vector3(1, 0, 0);
  }
  return new THREE.Vector3().crossVectors(up, normal).normalize();
}

/**
 * Compute a robust perpendicular direction for an edge
 * Handles cases where edge direction is nearly parallel to outward
 */
function getEdgePerpendicular(edgeDir, outward) {
  const perp = new THREE.Vector3().crossVectors(edgeDir, outward);
  const len = perp.length();

  if (len < 0.001) {
    // Edge is nearly parallel to outward - use tangent plane fallback
    const tangent = getTangent(outward);
    perp.crossVectors(edgeDir, tangent);
    if (perp.length() < 0.001) {
      // Still degenerate - use other tangent
      const tangent2 = new THREE.Vector3()
        .crossVectors(outward, tangent)
        .normalize();
      perp.crossVectors(edgeDir, tangent2);
    }
  }

  return perp.normalize();
}

/**
 * Compute miter point where two offset lines meet
 */
function computeMiterSimple(
  vertex,
  dir1,
  dir2,
  perp1,
  perp2,
  halfThick,
  outward
) {
  // Offset starting points
  const p1 = vertex.clone().add(perp1.clone().multiplyScalar(halfThick));
  const p2 = vertex.clone().add(perp2.clone().multiplyScalar(halfThick));

  // If directions are nearly parallel, just return midpoint of offsets
  const dot = dir1.dot(dir2);
  if (Math.abs(dot) > 0.999) {
    return p1.clone().add(p2).multiplyScalar(0.5);
  }

  // Project to tangent plane and solve 2D intersection
  const tangent1 = getTangent(outward);
  const tangent2 = new THREE.Vector3()
    .crossVectors(outward, tangent1)
    .normalize();

  const p1_2d = [p1.dot(tangent1), p1.dot(tangent2)];
  const p2_2d = [p2.dot(tangent1), p2.dot(tangent2)];
  const d1_2d = [dir1.dot(tangent1), dir1.dot(tangent2)];
  const d2_2d = [dir2.dot(tangent1), dir2.dot(tangent2)];

  // Solve p1 + t*d1 = p2 + s*d2
  const det = d1_2d[0] * -d2_2d[1] - d1_2d[1] * -d2_2d[0];

  if (Math.abs(det) < 0.0001) {
    return p1.clone().add(p2).multiplyScalar(0.5);
  }

  const dx = p2_2d[0] - p1_2d[0];
  const dy = p2_2d[1] - p1_2d[1];
  const t = (dx * -d2_2d[1] - dy * -d2_2d[0]) / det;

  // Clamp to avoid extreme miter spikes
  const maxT = halfThick * 4;
  const clampedT = Math.max(-maxT, Math.min(maxT, t));

  return p1.clone().add(dir1.clone().multiplyScalar(clampedT));
}

/**
 * Create wall geometry for a single edge using precomputed boundary slots
 */
function createEdgeGeometry(
  v1,
  v2,
  idx1,
  idx2,
  vertexSlots,
  radius,
  outerRadius
) {
  const positions = [];
  const indices = [];

  const slots1 = vertexSlots.get(idx1);
  const slots2 = vertexSlots.get(idx2);

  // Find the boundary points for this edge at vertex 1
  let left1, right1;

  if (slots1.sorted.length === 1) {
    // Dead end - use the dedicated left/right slots
    for (const slot of slots1.slots) {
      if (slot.isLeft) left1 = slot.point;
      else right1 = slot.point;
    }
  } else {
    // Regular vertex - find slots by neighbor reference
    for (const slot of slots1.slots) {
      if (slot.nextNeighbor === idx2) left1 = slot.point;
      if (slot.prevNeighbor === idx2) right1 = slot.point;
    }
  }

  // Find boundary points at vertex 2
  let left2, right2;

  if (slots2.sorted.length === 1) {
    // Dead end - SWAP left/right because vertex 2 is looking back at vertex 1
    // So its "left" is actually the wall's right side from our perspective
    for (const slot of slots2.slots) {
      if (slot.isLeft) right2 = slot.point; // swapped
      else left2 = slot.point; // swapped
    }
  } else {
    // Regular vertex - find slots by neighbor reference
    for (const slot of slots2.slots) {
      if (slot.prevNeighbor === idx1) left2 = slot.point;
      if (slot.nextNeighbor === idx1) right2 = slot.point;
    }
  }

  // Fallback if not found (shouldn't happen)
  if (!left1 || !right1 || !left2 || !right2) {
    console.warn('Missing boundary points for edge', idx1, idx2);
    return { positions: [], indices: [] };
  }

  // Create 8 vertices: 4 at inner radius, 4 at outer radius
  // Order: left1, right1, right2, left2 at each radius
  const verts = [
    spherize(left1, radius), // 0
    spherize(right1, radius), // 1
    spherize(right2, radius), // 2
    spherize(left2, radius), // 3
    spherize(left1, outerRadius), // 4
    spherize(right1, outerRadius), // 5
    spherize(right2, outerRadius), // 6
    spherize(left2, outerRadius), // 7
  ];

  for (const v of verts) {
    positions.push(v.x, v.y, v.z);
  }

  // Faces
  // Left side: 0, 3, 7, 4
  indices.push(0, 3, 7, 0, 7, 4);
  // Right side: 2, 1, 5, 6
  indices.push(2, 1, 5, 2, 5, 6);
  // Top: 4, 7, 6, 5
  indices.push(4, 7, 6, 4, 6, 5);
  // Bottom: 0, 1, 2, 3
  indices.push(0, 1, 2, 0, 2, 3);

  return { positions, indices };
}

/**
 * Create cap at dead end
 */
function createDeadEndCap(vertex, slots, radius, outerRadius) {
  const positions = [];
  const indices = [];

  // Dead end has exactly 2 slots (one on each side of the single edge)
  if (slots.length !== 2) return { positions: [], indices: [] };

  const p1 = spherize(slots[0].point, radius);
  const p2 = spherize(slots[1].point, radius);
  const p1_out = spherize(slots[0].point, outerRadius);
  const p2_out = spherize(slots[1].point, outerRadius);

  positions.push(p1.x, p1.y, p1.z); // 0
  positions.push(p2.x, p2.y, p2.z); // 1
  positions.push(p1_out.x, p1_out.y, p1_out.z); // 2
  positions.push(p2_out.x, p2_out.y, p2_out.z); // 3

  // Cap quad - winding reversed to face outward (away from the wall)
  indices.push(0, 3, 1, 0, 2, 3);

  return { positions, indices };
}

/**
 * Create fill geometry at junctions (T, +, etc)
 * Fills the top and bottom polygon where multiple edges meet
 */
function createJunctionFill(vertex, slots, radius, outerRadius) {
  const positions = [];
  const indices = [];

  const n = slots.length;
  if (n < 3) return { positions: [], indices: [] };

  // Center point at inner and outer radius
  const centerInner = spherize(vertex, radius);
  const centerOuter = spherize(vertex, outerRadius);

  // Add center vertices
  positions.push(centerInner.x, centerInner.y, centerInner.z); // 0 - inner center
  positions.push(centerOuter.x, centerOuter.y, centerOuter.z); // 1 - outer center

  // Add boundary vertices (inner and outer for each slot point)
  for (const slot of slots) {
    const inner = spherize(slot.point, radius);
    const outer = spherize(slot.point, outerRadius);
    positions.push(inner.x, inner.y, inner.z);
    positions.push(outer.x, outer.y, outer.z);
  }

  // Create triangle fan for bottom (inner radius) and top (outer radius)
  for (let i = 0; i < n; i++) {
    const currInner = 2 + i * 2; // inner vertex for slot i
    const currOuter = 2 + i * 2 + 1; // outer vertex for slot i
    const nextInner = 2 + ((i + 1) % n) * 2;
    const nextOuter = 2 + ((i + 1) % n) * 2 + 1;

    // Bottom triangle (inner radius) - winding for bottom face
    indices.push(0, nextInner, currInner);
    // Top triangle (outer radius) - opposite winding for top face
    indices.push(1, currOuter, nextOuter);
  }

  return { positions, indices };
}

/**
 * Spherize a point to given radius
 */
function spherize(point, radius) {
  return point.clone().normalize().multiplyScalar(radius);
}
